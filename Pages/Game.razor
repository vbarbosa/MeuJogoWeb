@page "/game"
@inject IJSRuntime JS

<canvas id="gameCanvas" width="800" height="600" tabindex="0"></canvas>

@code {
    // Dimensões fixas
    const int width = 800, height = 600;

    // Bola
    double ballX, ballY;
    const int ballR = 13;
    double vx, vy;
    double gravity = 0.5;       // Gravidade base

    // Paddle
    const int paddleW = 230, paddleH = 25;
    double paddleX, paddleY;
    const int PaddleSpeed = 25;
    int moveDir = 0;

    // HUD / Estado
    int score;
    DateTime startTime;
    bool paused;
    bool isDeath;
    int lastScore;
    string sessionId;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            InitializeGame();

            var objRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("startBreakout", objRef, "gameCanvas");
            await JS.InvokeVoidAsync("registerKeyHandlers", objRef);
        }
    }

    void InitializeGame()
    {
        // posição inicial
        ballX = 100;
        ballY = 100;
        vx = 5;
        vy = -10;

        paddleX = (width - paddleW) / 2;
        paddleY = height - 100;
        moveDir = 0;

        score = 0;
        startTime = DateTime.Now;
        paused = false;
        isDeath = false;
        sessionId = Guid.NewGuid().ToString("N").Substring(0, 7);

        // inicializa gravidade
        gravity = 0.5;
    }

    [JSInvokable]
    public object UpdateFrame()
    {
        if (paused)
            return BuildFrame(pause: true);

        // Ajusta gravidade dinamicamente com base no score
        const double baseGravity = 0.5;
        const double perPointIncr = 0.001;
        const double maxGravity = 1.0;
        gravity = Math.Min(baseGravity + score * perPointIncr, maxGravity);

        // --- paddle ---
        double paddleVel = 0;
        if (moveDir == -1 && paddleX > 0) { paddleX -= PaddleSpeed; paddleVel = -PaddleSpeed; }
        if (moveDir == 1 && paddleX + paddleW < width) { paddleX += PaddleSpeed; paddleVel = PaddleSpeed; }

        // --- física bola ---
        vy += gravity;
        ballX += vx;
        ballY += vy;

        if (ballX <= 0 || ballX + ballR * 2 >= width) vx *= -1;
        if (ballY <= 0) { ballY = 0; vy *= -1; }

        // --- colisão paddle com física correta ---
        if (ballY + ballR * 2 >= paddleY &&
            ballX + ballR * 2 >= paddleX &&
            ballX <= paddleX + paddleW && vy > 0)
        {
            // normaliza ponto de impacto (-1 a +1)
            double hitPos = ((ballX + ballR) - (paddleX + paddleW / 2.0))
                            / (paddleW / 2.0);

            // magnitude da velocidade antes do impacto
            double speed = Math.Sqrt(vx * vx + vy * vy);

            // parâmetros físicos
            const double restitution = 1.0;  // sem perda de energia vertical
            const double friction = 0.1;     // atrito entre paddle e bola

            // componente horizontal desejada pelo impacto
            double impactVx = hitPos * speed;

            // velocidade relativa no eixo X (impacto vs paddle)
            double relVx = impactVx - paddleVel;

            // aplica atrito na relativa
            relVx *= (1 - friction);

            // reconstrói velocidade absoluta adicionando a do paddle
            vx = relVx + paddleVel;

            // componente vertical conservando energia (restituição)
            double vyMag = Math.Sqrt(Math.Max(0, speed * speed - vx * vx));
            vy = -vyMag * restitution;

            // reposiciona a bola no topo do paddle
            ballY = paddleY - ballR * 2;

            score++;
        }

        // --- chão / game over ---
        if (ballY + ballR * 2 >= height - 2)
        {
            ballY = height - ballR * 2 - 2;
            paused = true;
            isDeath = true;
            lastScore = score;
            return BuildFrame(pause: true);
        }

        return BuildFrame(pause: false);
    }

    object BuildFrame(bool pause) => new
    {
        ballX,
        ballY,
        ballR,
        paddleX,
        paddleY,
        paddleW,
        paddleH,
        score,
        elapsed = (int)(DateTime.Now - startTime).TotalSeconds,
        pause,
        isDeath,
        lastScore,
        sessionId
    };

    [JSInvokable]
    public void KeyDown(int dir) => moveDir = dir;

    [JSInvokable]
    public void KeyUp(int dir)
    {
        if (moveDir == dir) moveDir = 0;
    }

    [JSInvokable]
    public void TogglePause()
    {
        if (!isDeath)
            paused = !paused;
    }

    [JSInvokable]
    public void ResetGame()
    {
        InitializeGame();
    }
}
